<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Evil Pencil Dodge â€” Prototype</title>
  <style>
    html,body { margin:0; height:100%; background:#0b1020; color:#eee; font-family:system-ui,Arial; }
    canvas { display:block; }
    .hint {
      position: fixed; left: 12px; top: 12px;
      background: rgba(255,255,255,0.04); padding:8px 12px; border-radius:8px;
      font-size:13px; color:#ddd; backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div class="hint">Move with your mouse (stay below grey line). Reload to restart. Nice aim btw ðŸ˜‰</div>
  <canvas id="gameCanvas"></canvas>

<script>
    /* ======================
   Asset loading
   ====================== */
const assets = {
  pencil: new Image(),
  gun: new Image(),
  bullet: new Image()
};
let assetsReady = false;
let assetsToLoad = 3;
function markLoaded(){ if(--assetsToLoad <= 0) assetsReady = true; }

assets.pencil.src = 'assets/pencil.png';
assets.gun.src    = 'assets/gun.png';
assets.bullet.src = 'assets/bullet.png';

assets.pencil.onload = markLoaded; assets.pencil.onerror = markLoaded;
assets.gun.onload    = markLoaded; assets.gun.onerror    = markLoaded;
assets.bullet.onload = markLoaded; assets.bullet.onerror = markLoaded;
/* ======================
   Config & globals
   ====================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const PENCIL_ZONE_HEIGHT = 200; // top area where pencil wanders
const PLAY_TOP = PENCIL_ZONE_HEIGHT;
const PLAY_BOTTOM = () => canvas.height;

let mouseX = canvas.width/2;
let mouseY = (PLAY_TOP + canvas.height)/2;

canvas.addEventListener('mousemove', (e) => {
  // constrain player to playable area
  const rect = canvas.getBoundingClientRect();
  mouseX = Math.max(0, Math.min(e.clientX - rect.left, canvas.width));
  mouseY = Math.max(PLAY_TOP, Math.min(e.clientY - rect.top, canvas.height));
});

/* ======================
   Utility helpers
   ====================== */
function lerp(a,b,t){ return a + (b-a)*t; }
function distance(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }


/* ======================
   Bullet class (image + rotation)
   ====================== */
class Bullet {
  constructor(x,y, vx,vy) {
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.radius = 6;
    this.alive = true;
  }
  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    if (this.x < -50 || this.x > canvas.width+50 || this.y < -50 || this.y > canvas.height+50) this.alive = false;
  }
  draw() {
    if (assetsReady && assets.bullet.complete) {
      ctx.save();
      ctx.translate(this.x, this.y);
      const angle = Math.atan2(this.vy, this.vx);
      ctx.rotate(angle);
      const size = Math.max(12, this.radius * 3); // tweak size
      ctx.drawImage(assets.bullet, -size/2, -size/2, size, size);
      ctx.restore();
      return;
    }
    // fallback: circle
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.beginPath();
    ctx.fillStyle = "#ffd166";
    ctx.arc(0,0,this.radius,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.beginPath(); ctx.arc(-2,-2,2,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* ======================
   GunAttack (accepts optional y, draws with image)
   ====================== */
class GunAttack {
  constructor(x, y = Math.max(20, PENCIL_ZONE_HEIGHT - 60)) {
    this.x = x;
    // ensure gun is inside pencil zone (y < PENCIL_ZONE_HEIGHT)
    this.y = Math.min(PENCIL_ZONE_HEIGHT - 20, Math.max(20, y));
    this.scale = 0;
    this.alive = true;

    this.drawDuration = 600;
    this.elapsed = 0;

    this.shootCount = 3;
    this.shotsFired = 0;
    this.shootInterval = 380; // slightly longer between shots
    this.shootTimer = 0;

    this.postLife = 900;
    this.afterTimer = 0;
    this.bulletSpeed = 0.65;

    this.localBullets = [];
  }

  update(dt) {
    if (!this.alive) return;

    this.elapsed += dt;
    if (this.elapsed < this.drawDuration) {
      const t = this.elapsed / this.drawDuration;
      this.scale = Math.min(1.12, (1 - Math.pow(1-t,3)));
    } else {
      this.shootTimer += dt;
      if (this.shotsFired < this.shootCount && this.shootTimer >= this.shootInterval) {
        this.shootTimer = 0;
        this.fireOneBullet();
        this.shotsFired++;
      }
      if (this.shotsFired >= this.shootCount) {
        this.localBullets = this.localBullets.filter(b => b.alive);
        if (this.localBullets.length === 0) {
          this.afterTimer += dt;
          if (this.afterTimer >= this.postLife) this.alive = false;
        }
      }
    }
    for (let b of this.localBullets) b.update(dt);
  }

  fireOneBullet() {
    const targetX = mouseX;
    const targetY = mouseY;
    const dx = targetX - this.x;
    const dy = targetY - this.y;
    const mag = Math.hypot(dx,dy) || 1;
    const vx = dx / mag * this.bulletSpeed;
    const vy = dy / mag * this.bulletSpeed;
    const bullet = new Bullet(this.x, this.y, vx, vy);
    this.localBullets.push(bullet);
    bullets.push(bullet);
    this.scale = 1.25;
    setTimeout(()=> { this.scale = 1; }, 80);
  }

  draw() {
    if (!this.alive) return;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.scale, this.scale);
    if (assetsReady && assets.gun.complete) {
      const iw = assets.gun.width;
      const ih = assets.gun.height;
      // draw centered
      const w = 120; const h = 56;
      ctx.drawImage(assets.gun, -w/2, -h/2, w, h);
    } else {
      // fallback stylized gun (like your original)
      ctx.translate(-40, -20);
      ctx.fillStyle = "#525252";
      roundRect(ctx, 0, 0, 100, 40, 8); ctx.fill();
      ctx.fillStyle = "#2b2b2b";
      ctx.fillRect(90, 12, 40, 16);
      ctx.fillStyle = "#6b6b6b";
      ctx.fillRect(8,8,30,24);
      ctx.fillStyle = "#111";
      ctx.fillRect(30, -8, 16, 8);
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.beginPath(); ctx.ellipse(40,56,48,8,0,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
}

/* nice helper for rounded boxes */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ======================
   EvilPencil controller
   - moves to random x positions (left/center/right)
   - when arriving it 'draws' for some ms, then spawns a GunAttack
   - increases speed / reduces draw time over time for difficulty
   ====================== */
const PencilState = { IDLE: 'idle', MOVING: 'moving', DRAWING: 'drawing' };

class EvilPencil {
  constructor() {
    this.x = canvas.width/2;
    this.y = 30;
    this.state = PencilState.IDLE;

    this.targetX = this.x;
    // gentler starting values
    this.moveSpeed = 0.22;  // px per ms (slower start)
    this.drawTime = 900;    // ms base (longer draw initially)
    this.frameTimer = 0;
    this.wobble = 0;

    this.idleTimer = 0;
    this.idleDelay = 380; // ms between actions (longer)

    this.actionsTaken = 0; // track how many spawns to scale difficulty
  }

  update(dt) {
    this.wobble += dt * 0.005;
    if (this.state === PencilState.MOVING) {
      const dist = this.targetX - this.x;
      const dir = Math.sign(dist);
      const step = this.moveSpeed * dt;
      if (Math.abs(dist) <= step) {
        this.x = this.targetX;
        this.startDrawing();
      } else {
        this.x += dir * step;
      }
    } else if (this.state === PencilState.IDLE) {
      this.idleTimer += dt;
      if (this.idleTimer >= this.idleDelay) {
        this.idleTimer = 0;
        this.chooseNewTargetAndMove();
      }
    }
  }

  chooseNewTargetAndMove() {
    // choose any x across width with margin for variety (not just 3 columns)
    const margin = Math.max(80, canvas.width * 0.05);
    this.targetX = Math.random() * (canvas.width - margin*2) + margin;
    this.state = PencilState.MOVING;
  }

  startDrawing() {
    this.state = PencilState.DRAWING;
    const finalDrawDuration = Math.max(220, this.drawTime);
    setTimeout(() => {
      // spawn gun at pencil.x but random y inside the pencil zone
      const gunY = Math.random() * (PENCIL_ZONE_HEIGHT - 60) + 30;
      const gun = new GunAttack(this.x, gunY);
      guns.push(gun);
      this.state = PencilState.IDLE;
      this.speedUp();
      this.actionsTaken++;
    }, finalDrawDuration);
  }
    speedUp() {
    // much slower ramp â€” smaller increments
    this.moveSpeed *= 1.012;   // 1.2% faster per action (instead of 3%)
    this.drawTime *= 0.997;    // tiny decrease in draw time (instead of 4%)
    this.idleDelay = Math.max(110, this.idleDelay * 0.997);
    // you can also optionally change gun properties over time (not too aggressively)
    if (this.actionsTaken % 8 === 0) {
      // every 8 spawns slightly increase bullet speed of future guns
      // (we won't mutate existing guns - new guns will be slightly faster)
      // if you want we can implement a global difficulty multiplier
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    const wob = Math.sin(this.wobble) * 6;
    ctx.rotate((wob * Math.PI/180) * 0.4);

    if (assetsReady && assets.pencil.complete) {
      // draw pencil image centered
      const w = 160, h = 48;
      ctx.drawImage(assets.pencil, -w/2, -h/2, w, h);
    } else {
      // fallback original draw
      ctx.fillStyle = "#ffb703";
      roundRect(ctx, -8, -8, 120, 24, 6);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(110,4); ctx.lineTo(130,0); ctx.lineTo(110,-4); ctx.closePath();
      ctx.fillStyle = "#8b5e34";
      ctx.fill();
      ctx.beginPath(); ctx.moveTo(130,0); ctx.lineTo(138, -3); ctx.lineTo(138,3); ctx.closePath();
      ctx.fillStyle = "#1d1d1b"; ctx.fill();
      ctx.fillStyle = "#d62828"; ctx.fillRect(-16, -6, 10, 12);
    }

    ctx.restore();

    if (this.state === PencilState.DRAWING) {
      ctx.save();
      ctx.strokeStyle = "#ffffff22";
      ctx.lineWidth = 2;
      ctx.beginPath();
      const sx = this.x - 60;
      for (let i=0;i<6;i++){
        const px = sx + i*20;
        const py = PENCIL_ZONE_HEIGHT + 18 + Math.sin((i + Date.now()*0.003))*8;
        ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }
  }
}

/* ======================
   Global lists
   ====================== */
const guns = [];
const bullets = [];
const pencil = new EvilPencil();

/* start the pencil cycle after a small delay */
setTimeout(()=> pencil.chooseNewTargetAndMove(), 600);

/* ======================
   Main game loop (time-based for stable speeds)
   ====================== */
let lastTime = performance.now();
function loop(now) {
  const dt = Math.min(60, now - lastTime); // ms, clamp a bit
  lastTime = now;

  update(dt);
  render();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt) {
  pencil.update(dt);
  // update guns (and their bullets)
  for (let g of guns) g.update(dt);
  // cleanup dead guns
  for (let i = guns.length-1; i>=0; i--) if (!guns[i].alive) guns.splice(i,1);

  // update global bullets array
  for (let b of bullets) b.update(dt);
  for (let i = bullets.length-1; i>=0; i--){
    if (!bullets[i].alive) bullets.splice(i,1);
  }

  // Keep player inside play area if window resized while moving
  mouseY = Math.max(PLAY_TOP, Math.min(mouseY, canvas.height));
}

function render() {
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // background gradient
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, '#0b1020'); g.addColorStop(1, '#071022');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  drawZones();
  pencil.draw();

  // draw guns
  for (let g of guns) g.draw();

  // draw bullets
  for (let b of bullets) b.draw();

  drawPlayer();
}

function drawZones() {
  // pencil zone
  ctx.fillStyle = "#2a2a2a";
  ctx.fillRect(0,0,canvas.width, PENCIL_ZONE_HEIGHT);

  // separator line
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0,PENCIL_ZONE_HEIGHT); ctx.lineTo(canvas.width, PENCIL_ZONE_HEIGHT); ctx.stroke();
}

function drawPlayer() {
  // player dot
  ctx.beginPath();
  ctx.fillStyle = "#da0303";
  ctx.arc(mouseX, mouseY, 10, 0, Math.PI*2); ctx.fill();
  // small halo
  ctx.beginPath();
  ctx.strokeStyle = "rgba(218,3,3,0.14)"; ctx.lineWidth = 6;
  ctx.arc(mouseX, mouseY, 16, 0, Math.PI*2); ctx.stroke();
}

/* ======================
   Future TODOs (collision, more attacks, pooling)
   - To add collision: check bullets vs player circle (distance < sum radii)
   - Add sword/laser: create classes similar to GunAttack
   - Add sprite frames: replace shape draw with images and a frameIndex
   - Add score/HP & UI
   ====================== */

</script>
</body>
</html>
